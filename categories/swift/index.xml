<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Swift on goozenlab</title>
    <link>https://goozenlab.com/categories/swift/</link>
    <description>Recent content in Swift on goozenlab</description>
    <generator>Hugo -- gohugo.io</generator>
    <managingEditor>goozenlab@gmail.com (jin)</managingEditor>
    <webMaster>goozenlab@gmail.com (jin)</webMaster>
    <copyright>Copyright (c) 2018, goozenlab; all rights reserved.</copyright>
    <lastBuildDate>Sun, 28 Aug 2016 09:30:00 +0700</lastBuildDate>
    
	<atom:link href="https://goozenlab.com/categories/swift/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title> 半透明のモーダルビュー</title>
      <link>https://goozenlab.com/blog/2016/08/modalview-over/</link>
      <pubDate>Sun, 28 Aug 2016 09:30:00 +0700</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>https://goozenlab.com/blog/2016/08/modalview-over/</guid>
      <description>iOS6の頃はなんか面倒だったような気がした、下のViewが透けて見えるようなモーダルビューの設定。非常に簡単にできるようになってました。
半透明のモーダルビュー設定 まずはモーダルビュー自体を半透明化します。背景色を選び透明度を決めます。
それと、StoryboardにてのSegway設定だとなぜかうまく物と、行かないものがありました。あまり深くは掘り下げていませんが、とりあえず情報まで（解決：下記参照）。
二通りあるようですが、厳密な違いはわからず、表示をテストで行うが全く同じに見えます。。
 override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) { if segue.identifier == &amp;quot;toSettingView&amp;quot; { if let destinationVC = segue.destinationViewController as? SettingViewController { destinationVC.modalPresentationStyle = UIModalPresentationStyle.OverCurrentContext // UIModalPresentationStyle.OverFullScreen destinationVC.delegate = self } } }  で、色々といじっていたら、インスペクターのPresentationの所でも変更ができます。コードでうまくいかなかった時にはこちらでいけます。知らなかったわ。。。。
見た感じこんな風になります（使わないけど、悪い例）。まぁ想像通り、使うなら文字色とか背景の色とかを考慮する必要がありますわな。
追記：すぐ上の白点ボタンの位置がずれてるな。。。</description>
    </item>
    
    <item>
      <title>StatusBarメモ</title>
      <link>https://goozenlab.com/blog/2016/08/statusbar-memo/</link>
      <pubDate>Fri, 26 Aug 2016 09:30:00 +0700</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>https://goozenlab.com/blog/2016/08/statusbar-memo/</guid>
      <description>アプリにて、StatusBarを隠す事が多いのだけれど、いつもやり方を忘れるのでメモしておく。
まずは全体的な設定を、info.plistにて View Controller-based status bar appearance を追加。(ここのところがいつも「どれだったっけ？」とわからなくなる。）
info.plistに直接書き込むなら、以下を追加。
&amp;lt;key&amp;gt;UIViewControllerBasedStatusBarAppearance&amp;lt;/key&amp;gt; &amp;lt;false/&amp;gt;  そして、変更したいビューの適当なところ、ViewDidLoad に追加コード。
UIApplication.sharedApplication().statusBarHidden = true  もしくは、オーバーライドしても動くはず。
override func prefersStatusBarHidden() -&amp;gt; Bool { return true }  そして、ステータスバーの文字色、黒文字を白文字に変えるには、statusBarStyleStyleを .LightContent に変更する。
UIApplication.sharedApplication().statusBarStyle = .LightContent  </description>
    </item>
    
    <item>
      <title>Lite VersionとAdmob</title>
      <link>https://goozenlab.com/blog/2016/08/lite-admob/</link>
      <pubDate>Thu, 25 Aug 2016 09:30:00 +0700</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>https://goozenlab.com/blog/2016/08/lite-admob/</guid>
      <description>Swiftへの移行がちょっと落ち着いてきたので、お次はライトバージョンの制作に移る。同じプロジェクト内でライト版のターゲットをもつ方法で行います。ライト版では広告を表示するため、コード内のマクロで作業の分離を行います。(XCode7.3.1にて)
 ターゲットのコピーと調整 スキームの変更 新しいInfo.plistのリネーム、変更と移動 コンパイル時のマクロ設定 アイコンの追加  が主な作業の流れになります。
まずはプロジェクトのメインターゲットを Duplicate します。
スキーム名の変更はできないようなので、Editボタンの上の＋より、新しいスキームを追加します。ここの、cosper copyのものは＋の横のーボタンで消去します。
Info.plistのコピーの cosper copy-Info.plist はなぜか諸々のファイルのフォルダーの外に作られます。ちょっと面倒ですが、リネームしリファレンスから除き、プロジェクトにコピーして移動、そしていらなくなったファイルを削除をしましょう。
そしてビルドセッティング内のInfo.plistパラメーターをディレクトリー名を含めたファイル名に変更します。
そして、ターゲットの設定をします。（バンドル名やその他必要なもの）
最後に、コンパイル時のマクロ設定をします。#if LITE で処理を分岐できるようにします。LITE_VERSIONでもFREE_VERSIONでもご自分に適したものにしてください。
マクロの設定は、ビルドセティングより、右のサーチボックスから検索していくと良いです。フル・ライト両方のターゲットで設定が必要です。ライトにて LITE=1 を、
フルバージョンの方には LITE=0 を書き込みます。選択すると入力画面が出てきます。
そして、ライトバージョンでは、コンパイラーのカスタムフラグを設定します。
アイコンもライトバージョン用に追加、変更します。アイコンは、Assets.xcassetsより作成し、ターゲットにて設定します。
これで、ライトバージョンのターゲットが完成です。次に、ライトバージョンに広告を入れたいと思います。
AdMobの追加 iAdは終了してしまいましたので、定番Googleの AdMob をインストールします。CocoaPods を使って簡単にプロジェクトに追加することもできるのですが、私の開発機の不思議な不具合でココポッドを設定していません。。ファイルを落としてフレームワークを追加という手動インストールをします。（また、近くCocoaPodsを使った方法をアップデートするかもしれません。とりあえずココポッドでのインストール時には、Podfileに target &#39;xx lite&#39; do ... で切り分ければいいのかな。）
フレームワーク 必要なフレームワークは、以下。
 GoogleMobileAds.framework: Googleサイトよりダウンロード、プロジェクトにコピー (ターゲットをライトバージョンのみにするのを忘れずに）  プロジェクトからターゲットを選択して、一番下のLinked Frameworks and Librariesより追加、コマンド＋クリックで複数選択可能。
 AdSupport AudioToolbox AVFoundation CoreGraphics CoreTelephony EventKit EventKitUI MessageUI StoreKit SystemConfiguration  以上で準備完了。実装していきます。
コーディング マクロを使って、以下の形で処理を分けることができます。</description>
    </item>
    
    <item>
      <title>イフレット</title>
      <link>https://goozenlab.com/blog/2016/08/if-let/</link>
      <pubDate>Thu, 18 Aug 2016 09:30:00 +0700</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>https://goozenlab.com/blog/2016/08/if-let/</guid>
      <description>fatal error: unexpectedly found nil while unwrapping an Optional value
nil値が戻ってくる可能性のある時の処理方法。
tableCellに値を渡す時を例に、
# if let xx = yy { } else { } if let lock = event.isLocked as? Bool { cell.isLocked = lock } else { cell.isLocked = false }  で新しく、guard let なんてのが出てきて、こんな風に書き換える事ができ、（else以降の役割がよくわからない。）
# guard let xx = y else {] guard let lock = event.isLocked as? Bool else { return } cell.isLocked = lock  そしてしかも、簡略した（?：ニル、？：なの）xx = yy ?</description>
    </item>
    
    <item>
      <title>filteredArrayUsingPredicate</title>
      <link>https://goozenlab.com/blog/2016/08/array_filter/</link>
      <pubDate>Thu, 04 Aug 2016 18:30:00 +0700</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>https://goozenlab.com/blog/2016/08/array_filter/</guid>
      <description>拙作dandoriのswift移行中、中々進みません。
Objective-Cで使っていた、filteredArrayUsingPredicate が Swiftでは簡略化。.filterメソッドを使い、ブロックで処理を書き込みます。。。
ブロック表記が出てくると目が点になってしまう私。。。
以下 Objective-C での表記
NSArray *myTasks = [[NSArray alloc] initWithArray:[event.tasks allObjects]]; NSPredicate *hotPredicate = [NSPredicate predicateWithFormat:@&amp;quot;isRedHot == YES&amp;quot;]; NSArray *filteredArray = [myTasks filteredArrayUsingPredicate:hotPredicate]; return [filteredArray count] &amp;gt; 0;  Swiftで書き上げにはブロック内に(user: UserDetails) -&amp;gt; Bool in で書き込む方法もあり試すもエラーがでる。。あーーー、ブロック、、意味わからん。。。しかし、救いの神のNSPredicateを使った場合は以下、随分スッキリします。（こっちの方が全然良いわ。。 $0.isRedHot = &amp;quot;YES&amp;quot; 何じゃかんじゃより。。）書き上げるとこんな感じ。
let myTasks = tasks?.allObjects let predicate = NSPredicate(format: &amp;quot;isRedHot == YES&amp;quot;) let filteredArray = myTasks?.filter( { predicate.evaluateWithObject($0) } ) return filteredArray!.count &amp;gt; 0  </description>
    </item>
    
    <item>
      <title>乱数を発生させる</title>
      <link>https://goozenlab.com/blog/2016/03/arc4random_uniform/</link>
      <pubDate>Fri, 18 Mar 2016 11:30:00 +0700</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>https://goozenlab.com/blog/2016/03/arc4random_uniform/</guid>
      <description> rand() 今まではrand()使い、srand()にて乱数の初期化をし数値を得ていた。
 srand(time(nil)); rand()%300;  arc4random_uniform() 上記の形だとSwift時にエラーが出る為、乱数の初期化が不要な物に変更し以下の形に落ち着く。
 Int(arc4random_uniform(300))  </description>
    </item>
    
    <item>
      <title>midXで中心を求める</title>
      <link>https://goozenlab.com/blog/2015/07/midx-swift/</link>
      <pubDate>Sat, 11 Jul 2015 09:30:00 +0600</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>https://goozenlab.com/blog/2015/07/midx-swift/</guid>
      <description>今までは中心を求めるのに素直に、
let center: CGFloat = self.frame.width / 2  と行ってきたけれども、.midX/midY
let center: CGFloat = self.frame.midX  とスマート、かつ格好良くできます。</description>
    </item>
    
    <item>
      <title>テーブルビューセルの境界線を消す</title>
      <link>https://goozenlab.com/blog/2015/04/tableview-separator/</link>
      <pubDate>Mon, 06 Apr 2015 19:30:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>https://goozenlab.com/blog/2015/04/tableview-separator/</guid>
      <description>テーブルビューセルの境界線を消すには下記のコードを追加。
self.tableView.separatorStyle = UITableViewCellSeparatorStyle.None  StoryBoardを使っている時は以下。</description>
    </item>
    
    <item>
      <title>ShakeはUIEventで</title>
      <link>https://goozenlab.com/blog/2015/03/swift-shake/</link>
      <pubDate>Fri, 27 Mar 2015 11:30:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>https://goozenlab.com/blog/2015/03/swift-shake/</guid>
      <description>色々と書き込んでいたシェイクの判別はUIEventを使うようになります。 えらく簡単になりました。
 override func viewDidAppear(animated: Bool) { super.viewDidAppear(animated) self.becomeFirstResponder() } override func canBecomeFirstResponder() -&amp;gt; Bool { return true } override func motionEnded(motion: UIEventSubtype, withEvent event: UIEvent!) { if(event.subtype == UIEventSubtype.MotionShake) { // // 処理 // } }  ※まぁ、間違っちゃーいね〜な。。</description>
    </item>
    
    <item>
      <title>performSelectorは無くなる</title>
      <link>https://goozenlab.com/blog/2015/03/performselector-timer/</link>
      <pubDate>Thu, 26 Mar 2015 10:30:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>https://goozenlab.com/blog/2015/03/performselector-timer/</guid>
      <description>ほぼ全ての拙作のアプリでは、テーブルセルでのバーの色変更タップとアップデートは時間差を使って行っています。
[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(notifiyUpdate) object:nil]; [self performSelector:@selector(notifiyUpdate) withObject:nil afterDelay:kUpdateCellShortInterval];  object-cで上記に書かれたperformSelectorはSwiftでは無くなってしまったようなので、以下のコードでは動かない。
 NSObject.cancelPreviousPerformRequestsWithTarget(self, selector: notify, object: nil) NSObject.performSelector(notify, withObject: self, afterDelay: Interval.UpdateCell)  幾つかの方法があるようですが、タイマーを使った方法が簡易でよいのですが、cancelPreviousPerformRequestsWithTargetが無用になってしまう。処理の事前キャンセルも必要があるので、少し修正して最終的には以下のようになる。
private var tapTimer: NSTimer? // 処理 cancelTimer() tapTimer = NSTimer.scheduledTimerWithTimeInterval(Interval.UpdateCell, target: self, selector: notify, userInfo: nil, repeats: false) // func cancelTimer() { if tappingTimer != nil { tappingTimer!.invalidate() } }  </description>
    </item>
    
    <item>
      <title>printlnは気楽</title>
      <link>https://goozenlab.com/blog/2015/03/println-swift/</link>
      <pubDate>Wed, 25 Mar 2015 08:30:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>https://goozenlab.com/blog/2015/03/println-swift/</guid>
      <description>NSLogはまだ使えるようですが、swiftではprintln をログの書出しに使います。NSLogだとよく使っていた、 __PRETTY_FUNCTION__ は
Swift では __FILE__, __FUNCTION__, __LINE__ and __COLUMN__ のようになります。 使えそうなのは
 __FILE__ ：ファイル名 __LINE__ ：ライン番号 __FUNCTION__ ：ファンクション名  そして、値を表示したい時はそのままかそのままか\(...)で囲み適当に放り込む。もはや%dや%@は必要ないらしい。 小賢しいウォーニングも出なくなる。
println(__FUNCTION__, self.frame) println(__FUNCTION__,&amp;quot;screen is \(self.frame)&amp;quot;)  戻りは以下
(function, (0.0,706.0,414.0,30.0)) (function, screen is (0.0,706.0,414.0,30.0))  Swift Programming Language に書いてあるらしいので読むべ。</description>
    </item>
    
    <item>
      <title>NSDate() = [NSDate date]</title>
      <link>https://goozenlab.com/blog/2015/03/nsdate-swift/</link>
      <pubDate>Tue, 24 Mar 2015 08:30:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>https://goozenlab.com/blog/2015/03/nsdate-swift/</guid>
      <description>NSDateでの [NSDate date] はシンプルにイニシャライザーに統合され？、Swiftでは
NSDate()  でよろしい。
[NSDate dateWithTimeIntervalSinceNow:hoursGoodSleep * 60 * 60]  を、Swiftで書いてみると、
NSDate(timeIntervalSinceNow: hoursGoodSleep * 60 * 60)  エラーが出る。hoursGoodSleep は Float だし抜かりは無いような、、、
正しくは、Doubleでエラーは消える。こうゆう所は割と厳しいのね。。</description>
    </item>
    
    <item>
      <title>ビューサイクルとアプリ復帰時の処理</title>
      <link>https://goozenlab.com/blog/2015/03/view-cycle/</link>
      <pubDate>Sat, 21 Mar 2015 12:30:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>https://goozenlab.com/blog/2015/03/view-cycle/</guid>
      <description> たまに、何処に何の処理を入れれば良いか分からなくなるので、簡単にまとめる。
起動時 アプリの起動時には以下の順で呼ばれる。
 viewDidLoad() viewWillAppear viewDidAppear　※すべての画像の処理が終わった後に呼ばれる。あまり使っていない。  モーダルビューより復帰 モーダルビューより戻ってくると以下の処理が再び呼ばれる。
 viewWillAppear viewDidAppear  ロック・スリープからの復帰時 ロック・スリープからの復帰は処理が行われない（厳密には、AppDelegate内では呼ばれる）ので、アプリの戻ってきた時の処理を追加する。 viewDidLoadに通知の設定する事で可能になる。Setting.bundleでフォントの設定等を変更し、アプリに戻ってきた時に使う。
// Notification Center let app: UIApplication = UIApplication.sharedApplication() NSNotificationCenter.defaultCenter().addObserver(self, selector: &amp;quot;applicationWillEnterForeground:&amp;quot;, name: UIApplicationWillEnterForegroundNotification, object: app)  と処理を追加する。
func applicationWillEnterForeground(notification: NSNotification) { println(__FUNCTION__) }  スリープに移行時 逆にスリープに入る時には復帰時と同じで、ApplicationWillEnterForeground の代わりに ApplicationDidEnterBackground を使えば良い。
 NSNotificationCenter.defaultCenter().addObserver(self, selector: &amp;quot;applicationDidEnterBackground:&amp;quot;, name: UIApplicationDidEnterBackgroundNotification, object: app)  </description>
    </item>
    
    <item>
      <title>NotificationSettings認証設定</title>
      <link>https://goozenlab.com/blog/2015/03/notification-setting/</link>
      <pubDate>Sat, 21 Mar 2015 08:30:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>https://goozenlab.com/blog/2015/03/notification-setting/</guid>
      <description>iOS8になりアプリケーションバッジや音等、ユーザーの認証が必要になっています。
AppDelegateに処理を入れてしまいます。
 application.registerUserNotificationSettings(UIUserNotificationSettings( forTypes: UIUserNotificationType.Sound | UIUserNotificationType.Alert | UIUserNotificationType.Badge, categories: nil))  以前コピペでUIUserNotificationType.Soundを付け忘れ長い事音が鳴らないソフトになっていた事があるので、ちょっと注意して必要なものだけ入れるようにしてます。（必要なくても全部入れても良いのだけども。。。）</description>
    </item>
    
    <item>
      <title>クラスが読み込めず [解決]</title>
      <link>https://goozenlab.com/blog/2015/03/load-managedobject/</link>
      <pubDate>Fri, 20 Mar 2015 10:30:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>https://goozenlab.com/blog/2015/03/load-managedobject/</guid>
      <description>もう、わざわざ動いている物をSwiftに移行するのも止めてしまおうか。どうせならAndroidに移植する方がまだよいか、、と思ってしまうほどでしたが、クラスが読み込めずで書いた問題が解決しました。
問題のエラーログ
CoreData: warning: Unable to load class named &#39;Item&#39; for entity &#39;Item&#39;. Class not found, using default NSManagedObject instead.  もしかしたらXcode6.2では問題でなくなっているかもしれませんが、とりあえず解決方法は以下。
 xcdatamodeldファイルを選択 CONFIGURATIONSを選択 右に出てくるEntitiies以下のClass名をディレクトリー名.Entity名にする  ※ 注意点は上記の場合kitchen.Itemでは無くtapas.Itemと、xcdatamodeld名では無く、ディレクトリ名を入れる事。見事にハマりました。
（散歩中に「もしや、ディレクトリー名では。。」と閃きました。なんでわざわざkitchen.xcdatamodeldという名前にしているのかは、自分で作ったのに不明。なんで余計な事をする？と自分に問い詰めたい。。）
うまく行かない場合  キャッシュをクリアーする DerivedDataのデーターを消す 新しいプロジェクトを作って、Modelを移行して試す  ※ 使っていたプロジェクトのままで動いた場合と（tapas)、キャッシュやDerivedDataのデーターを抜いてもうまく行かず、新しいプロジェクトを作り直してうまく行く場合がありました（ohaYo)。
蛇足：ネットでぱっと見て試すもうまく行かず、後で読み返すとその注意点が書いてあったりします。 小学校の通信簿に「少し聞いただけで、全部理解したと思ってしまうところがあります。もう少しじっくりと。（やれどーだこーだ）。」書いてあった事をふと思い出す。</description>
    </item>
    
    <item>
      <title>NSLocalizedString on swift</title>
      <link>https://goozenlab.com/blog/2015/03/nslocalizedstring-swift/</link>
      <pubDate>Thu, 19 Mar 2015 11:30:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>https://goozenlab.com/blog/2015/03/nslocalizedstring-swift/</guid>
      <description>NSLocalizedStringでエラーがでる
NSLocalizedString(&amp;quot;Timer&amp;quot;, comment: nil)  nilを&amp;quot;&amp;quot;空白に変更する。
NSLocalizedString(&amp;quot;NavigationBar.Button.Timer&amp;quot;, comment: &amp;quot;&amp;quot;)  Swiftではnilの扱いがちょっと掴めず、、至る所で問題になってる。。
ついでに中に入れる文言をかえる。以前は普通に&amp;quot;Timer&amp;quot;と書いていたところを今回からはドコゾの何某か分かるように&amp;quot;NavigationBar.Button.Timer&amp;quot;と少し詳しく書き込むようにする。</description>
    </item>
    
    <item>
      <title>delegate on swift</title>
      <link>https://goozenlab.com/blog/2015/03/delegate-swift/</link>
      <pubDate>Wed, 18 Mar 2015 11:30:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>https://goozenlab.com/blog/2015/03/delegate-swift/</guid>
      <description>デレゲートするクラス 以下の３つを書き加えればよい。
protocol MainHeaderViewDelegate { func sleepingTimerDidFinish(controller: MainHeaderView) }  var delegate:MainHeaderViewDelegate? = nil   self.delegate!.sleepingTimerDidFinish(self)  デレゲートで値を受け取るクラス MainHeaderViewDelegate と、functionを追加、処理を書き込みます。
class MainViewController: UIViewController, MainHeaderViewDelegate { ////// func sleepingTimerDidFinish(controller: MainHeaderView) { // 処理 } ///// }  ※ ソースは拙作のohayoからコピペ。</description>
    </item>
    
    <item>
      <title>UIButttonをSwiftで書く</title>
      <link>https://goozenlab.com/blog/2015/03/uibutton-swift/</link>
      <pubDate>Tue, 17 Mar 2015 08:30:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>https://goozenlab.com/blog/2015/03/uibutton-swift/</guid>
      <description>UIButttonをSwiftでプログラム的に書くと
buttonMoodExecelent = UIButton.buttonWithType(UIButtonType.Custom) as UIButton buttonMoodExecelent.frame = CGRect(x: 0, y: 0, width: 30, height: 30) buttonMoodExecelent.tag = TagButtonMood.Execelent buttonMoodExecelent.addTarget(self, action: &amp;quot;selectedMood:&amp;quot;, forControlEvents: .TouchUpInside) buttonMoodExecelent.setBackgroundImage(UIImage(named: &amp;quot;MoodExecelent&amp;quot;), forState: UIControlState.Normal) self.vew.addSubview(buttonMoodExecelent)  テキストタイトルの時には
buttonCancel.setTitle(&amp;quot;cancel&amp;quot;, forState: UIControlState.Normal)  テキストの色を変えるには、
buttonCancel.setTitleColor(UIColor.redColor(), forState: .Normal)  もっと細かく、フォント等も弄りたい時には、
setAttributedTitle:forStateを使うとさ。
※ ソースは拙作のohayoからコピペ。</description>
    </item>
    
    <item>
      <title>SwiftでConstantを扱う</title>
      <link>https://goozenlab.com/blog/2015/03/constants-swift/</link>
      <pubDate>Sat, 14 Mar 2015 09:30:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>https://goozenlab.com/blog/2015/03/constants-swift/</guid>
      <description>Swiftへの移行はスタンフォードの講義を聞きつつ進めたいところなのですが、ここネパールだとちょっと無理。 ネットでの情報も増えつつはあるように思えるが、まだまだな感じ。。
分からないことが多々あるが、進めていかないと、、
さて、これが正しい方法なのかは分からないけれども（一抹の不安があるが。。）、コンスタンツの扱いをSwiftにて行うには以下のようにしてます。
// // LocalConstants.swift // import Foundation import UIKit let ONE_DAY = 86400 struct UDKey { static let DisplayColorMode = &amp;quot;color_mode&amp;quot; } struct Default { static let ColorMode = &amp;quot;kawaii&amp;quot; }  で、他からのアクセスは
defaults.setValue(Default.ColorMode, forKey: UDKey.DisplayColorMode)  のようにしています。
※ Swiftでのenumが掴めない。意味が分からない。
追記 (3&amp;frasl;22)：import UIKitを追加する。</description>
    </item>
    
    <item>
      <title>クラスが読み込めず</title>
      <link>https://goozenlab.com/blog/2015/03/unable-to-load-class/</link>
      <pubDate>Thu, 12 Mar 2015 16:30:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>https://goozenlab.com/blog/2015/03/unable-to-load-class/</guid>
      <description>TapasをSwiftに移行中です。一番癖の無いアプリという事で白羽の矢があたりましたが、、、ブログに引っかかったところ等アップしていきたいと思ってます。
さて、さて、まずは、
2015-03-11 16:23:14.627 tapas[9910:539155] CoreData: warning: Unable to load class named &#39;Item&#39; for entity &#39;Item&#39;. Class not found, using default NSManagedObject instead.  というエラーがでる。ファイルはあるのだが、、
これは、動く。
func configureCell(cell: UITableViewCell, atIndexPath indexPath: NSIndexPath) { let item = self.fetchedResultsController.objectAtIndexPath(indexPath) as NSManagedObject var cell = cell as ListViewCell cell.textLabel?.text = item.valueForKey(&amp;quot;name&amp;quot;)!.description }  で、動かなーーーーい。。。
func configureCell(cell: UITableViewCell, atIndexPath indexPath: NSIndexPath) { let item = self.fetchedResultsController.objectAtIndexPath(indexPath) as Item var cell = cell as ListViewCell cell.</description>
    </item>
    
    <item>
      <title>UserDefaultの初期値設定</title>
      <link>https://goozenlab.com/blog/2015/03/userdefault-register-defaults/</link>
      <pubDate>Sun, 08 Mar 2015 08:30:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>https://goozenlab.com/blog/2015/03/userdefault-register-defaults/</guid>
      <description>AppDelegateで行なう処理の一つのUserDefaultの初期値設定をSwiftにて。
 // UserDefault Initial values var userDefaultsDefaults = NSMutableDictionary() userDefaultsDefaults.setValue(&amp;quot;String&amp;quot;, forKey: KEY_SETTING) userDefaultsDefaults.setValue(50, forKey: KEY_SETTING2) NSUserDefaults.standardUserDefaults().registerDefaults(userDefaultsDefaults)  数値も文字も気にせず書き込んでよいようです。
ポカラの水汲み場</description>
    </item>
    
    <item>
      <title>ニブレスプロジェクト</title>
      <link>https://goozenlab.com/blog/2015/02/xibless-project/</link>
      <pubDate>Thu, 26 Feb 2015 07:25:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>https://goozenlab.com/blog/2015/02/xibless-project/</guid>
      <description>swiftに移行中です。折角なのでなるべく奇麗にやり直したい、ずる無しでシンプルに仕上げたい。
ストーリーボードにはどうも馴染めず、結局中途半端にViewのコンポーネントをコードで書き込んだりする事になりそうなので、最初から何もなし状態から始めた方が良いと、、
 まずは storyboard/xib 無しテーブルビューベースのプロジェクト、MasterViewController (UITableViewController) がMainViewController です。  func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&amp;gt; Bool { // Override point for customization after application launch. self.window = UIWindow(frame: UIScreen.mainScreen().bounds) let masterViewController: MasterViewController = MasterViewController() masterViewController.managedObjectContext = self.managedObjectContext let navigationController = UINavigationController(rootViewController: masterViewController) self.window!.rootViewController = navigationController self.window!.makeKeyAndVisible() return true }   お次ぎは、storyboard/xib 無しビューコントローラーベースのプロジェクト、MainViewController (UIViewController) が文字通り MainViewController です。  、、が、、、、色々コンポーネントを追加していけば行くほど、アラートが上がってくる。。。（試行錯誤中）
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&amp;gt; Bool { // Override point for customization after application launch.</description>
    </item>
    
  </channel>
</rss>