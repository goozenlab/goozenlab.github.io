<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Objective C on goozenlab</title>
    <link>https://goozenlab.com/categories/objective-c/</link>
    <description>Recent content in Objective C on goozenlab</description>
    <generator>Hugo -- gohugo.io</generator>
    <managingEditor>goozenlab@gmail.com (jin)</managingEditor>
    <webMaster>goozenlab@gmail.com (jin)</webMaster>
    <lastBuildDate>Mon, 27 Jul 2015 18:30:00 +0500</lastBuildDate>
    
	<atom:link href="https://goozenlab.com/categories/objective-c/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>NSUserDefaultsのキーの削除</title>
      <link>https://goozenlab.com/blog/2015/07/userdefaults-remove-keys/</link>
      <pubDate>Mon, 27 Jul 2015 18:30:00 +0500</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>https://goozenlab.com/blog/2015/07/userdefaults-remove-keys/</guid>
      <description>アップデートをするたびに名前を変更したり、増えたり、減ったりしてグジャグジャになってしまう UserDefaults。私だけでは無いはず。。
既に設定してしまったUserDefaultsのキーを削除する方法は以下
[NSUserDefaults standardUserDefaults] removeObjectForKey:@&amp;quot;kFontName&amp;quot;]  アップデート時に実行させれば奇麗なままのUserDefaultを維持する事ができます。</description>
    </item>
    
    <item>
      <title>ライトウェイト マイグレーションでのアトリビュートの名称変更</title>
      <link>https://goozenlab.com/blog/2015/03/lightweight-migration-mapping/</link>
      <pubDate>Mon, 02 Mar 2015 08:30:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>https://goozenlab.com/blog/2015/03/lightweight-migration-mapping/</guid>
      <description>タイトルが長げーーーーーーな。。
さて、lightweight migration での移行で、アトリビュートの名前の変更がうまく行かないときは、マッピングがうまく機能していないのが原因です。（だとおもいます。）
そんなときは、マッピングファイルを作成して、
ファイルを訂正、追加して（source, destinationに注意）
あとは、optionsの設定を加え、
NSDictionary *options = @{NSMigratePersistentStoresAutomaticallyOption: @(YES), NSInferMappingModelAutomaticallyOption: @(YES)}  if (![_persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:storeURL options:options error:&amp;amp;error]) { # options:nil の箇所を options:options に変更  通常通り処理を行えば、うまく行きます。
- (NSPersistentStoreCoordinator *)persistentStoreCoordinator { // The persistent store coordinator for the application. This implementation creates and return a coordinator, having added the store for the application to it. if (_persistentStoreCoordinator != nil) { return _persistentStoreCoordinator; } // Create the coordinator and store _persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:[self managedObjectModel]]; NSURL *storeURL = [[self applicationDocumentsDirectory] URLByAppendingPathComponent:@&amp;quot;Littlist.</description>
    </item>
    
    <item>
      <title>Reminder：日時の書き込み</title>
      <link>https://goozenlab.com/blog/2015/02/reminder-duedatecomponents/</link>
      <pubDate>Mon, 23 Feb 2015 06:50:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>https://goozenlab.com/blog/2015/02/reminder-duedatecomponents/</guid>
      <description>リマインダーへの日時の書き込み
読み込み時には
event.dueDate = eventToRead.dueDateComponents.date; event.timeZone = eventToRead.dueDateComponents.timeZone;  と、あっさりと行くのですが、.dueDateComponents.date は readonly で書き込み時には日時をバラバラにしてまとめて書き込みます。
 NSCalendar *gregorian = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar]; unsigned unitFlags= NSYearCalendarUnit|NSMonthCalendarUnit | NSDayCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit |NSTimeZoneCalendarUnit; NSDateComponents *dailyComponents=[gregorian components:unitFlags fromDate:eventToExport.dueDate]; eventToWrite.dueDateComponents = dailyComponents; eventToWrite.timeZone = eventToExport.timeZone;  </description>
    </item>
    
    <item>
      <title>Reminderからの読込ではまる</title>
      <link>https://goozenlab.com/blog/2015/02/reminder-completion/</link>
      <pubDate>Sun, 22 Feb 2015 23:47:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>https://goozenlab.com/blog/2015/02/reminder-completion/</guid>
      <description>ここ数日 littlist.2.6.5にReminderへの書込み・取込みの機能の追加作業をしていました。
見事にハマったのが、取込みの
- (id)fetchRemindersMatchingPredicate:(NSPredicate *)predicate completion:(void (^)(NSArray *reminders))  でのブロック処理。 完了時にリマインダーのリストが所得でき、そのリストをセーブすれば簡単なはず、、なのが、、なぜがしっかりと保存されていない。中途半端にブロックから出てきている模様。
いろいろと試し、ネットで探したところ、見つかりました。
 // 事前に calendar の設定等をして、 __block NSArray *remindersToImport = nil; __block BOOL fetching = YES; NSPredicate *predicate = [eventStore predicateForRemindersInCalendars:@[calendar]]; [eventStore fetchRemindersMatchingPredicate:predicate completion:^(NSArray *ekReminders) { LOG_METHOD; remindersToImport = ekReminders; fetching = NO; }]; while (fetching) { [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.05]]; } // 作業がつづく  と、while の所で、処理が終わるまで一服させ、作業を続ける形です。（何のためのブロック処理なのか意味が分かりませんし、こういうのはバグというのでは？？）</description>
    </item>
    
  </channel>
</rss>