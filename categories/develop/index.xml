<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Develop on goozenlab</title>
    <link>http://goozenlab.com/categories/develop/</link>
    <description>Recent content in Develop on goozenlab</description>
    <generator>Hugo -- gohugo.io</generator>
    <managingEditor>goozenlab@gmail.com (jin)</managingEditor>
    <webMaster>goozenlab@gmail.com (jin)</webMaster>
    <lastBuildDate>Sat, 21 Mar 2015 08:30:00 +0545</lastBuildDate>
    <atom:link href="http://goozenlab.com/categories/develop/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>NotificationSettings認証設定</title>
      <link>http://goozenlab.com/blog/2015/03/notification-setting/</link>
      <pubDate>Sat, 21 Mar 2015 08:30:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>http://goozenlab.com/blog/2015/03/notification-setting/</guid>
      <description>&lt;p&gt;iOS8になりアプリケーションバッジや音等、ユーザーの認証が必要になっています。&lt;/p&gt;

&lt;p&gt;AppDelegateに処理を入れてしまいます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; application.registerUserNotificationSettings(UIUserNotificationSettings(
  forTypes: UIUserNotificationType.Sound | UIUserNotificationType.Alert | UIUserNotificationType.Badge,
  categories: nil))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以前コピペで&lt;code&gt;UIUserNotificationType.Sound&lt;/code&gt;を付け忘れ長い事音が鳴らないソフトになっていた事があるので、ちょっと注意して必要なものだけ入れるようにしてます。（必要なくても全部入れても良いのですが。。）&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ビューサイクルとアプリ復帰時の処理</title>
      <link>http://goozenlab.com/blog/2015/03/view-cycle/</link>
      <pubDate>Sat, 21 Mar 2015 08:30:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>http://goozenlab.com/blog/2015/03/view-cycle/</guid>
      <description>

&lt;p&gt;たまに、何処に何の処理を入れれば良いか分からなくなるので、簡単にまとめる。&lt;/p&gt;

&lt;h2 id=&#34;起動時:205901421f8bb17c75d7ebf5b8a21af9&#34;&gt;起動時&lt;/h2&gt;

&lt;p&gt;アプリの起動時には以下の順で呼ばれる。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;viewDidLoad()&lt;/li&gt;
&lt;li&gt;viewWillAppear&lt;/li&gt;
&lt;li&gt;viewDidAppear　※すべての画像の処理が終わった後に呼ばれる。あまり使っていない。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;モーダルビューより復帰:205901421f8bb17c75d7ebf5b8a21af9&#34;&gt;モーダルビューより復帰&lt;/h2&gt;

&lt;p&gt;モーダルビューより戻ってくると以下の処理が再び呼ばれる。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;viewWillAppear&lt;/li&gt;
&lt;li&gt;viewDidAppear&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;ロック-スリープからの復帰時:205901421f8bb17c75d7ebf5b8a21af9&#34;&gt;ロック・スリープからの復帰時&lt;/h2&gt;

&lt;p&gt;ロック・スリープからの復帰は処理が行われない（厳密には、AppDelegate内では呼ばれる）ので、アプリの戻ってきた時の処理を追加する。
viewDidLoadに通知の設定する事で可能になる。&lt;code&gt;Setting.bundle&lt;/code&gt;でフォントの設定等を変更し、アプリに戻ってきた時に使う。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Notification Center
let app: UIApplication = UIApplication.sharedApplication()
NSNotificationCenter.defaultCenter().addObserver(self, 
		selector: &amp;quot;applicationWillEnterForeground:&amp;quot;, name: UIApplicationWillEnterForegroundNotification, 
		object: app)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と処理を追加する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func applicationWillEnterForeground(notification: NSNotification) {
    println(__FUNCTION__)
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;スリープに移行時:205901421f8bb17c75d7ebf5b8a21af9&#34;&gt;スリープに移行時&lt;/h2&gt;

&lt;p&gt;逆にスリープに入る時には復帰時と同じで、&lt;code&gt;ApplicationWillEnterForeground&lt;/code&gt; の代わりに &lt;code&gt;ApplicationDidEnterBackground&lt;/code&gt; を使えば良い。（私はアプバッジの登録はAppDelegateで行ってます。）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; NSNotificationCenter.defaultCenter().addObserver(self, selector: &amp;quot;applicationDidEnterBackground:&amp;quot;, name: UIApplicationDidEnterBackgroundNotification, object: app)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Xcode 6.1とiOS8.2</title>
      <link>http://goozenlab.com/blog/2015/03/xcode611-ios82/</link>
      <pubDate>Sun, 15 Mar 2015 17:30:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>http://goozenlab.com/blog/2015/03/xcode611-ios82/</guid>
      <description>&lt;p&gt;検証機を何の迷いも無くiOS8.2にアップデートする。&lt;/p&gt;

&lt;p&gt;で、XCodeにてアプリをビルドしインストールしようと思ったら、、、、できん。。
このXCodeではサポートしないとの親切なエラーメッセージがでる。新しいバージョンのXCodeをインストールするにも、今いるネパールのネット環境ではXcode:2.58GBを落とすのにかなり時間がかかりそう。。。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2015-03-14-ios82.png&#34; alt=&#34;Xcode 6.1 with ios8.2&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;まぁ仕方ない。。タイもしくはインドに行くまで、シミュレータでしのぐしか無いな。。&lt;/p&gt;

&lt;p&gt;と思ったが、取りあえず試す。（随時アップデート）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2015-03-15 17:30　ルーターとの接続が10分おきに切れる。で、諦める。&lt;/li&gt;
&lt;li&gt;2015-03-15 13:00　再開するも、ダウンロードにはXCodeを落とせと、、で最初からやり直しになる。。&lt;/li&gt;
&lt;li&gt;2015-03-15 06:00　停電中&lt;/li&gt;
&lt;li&gt;2015-03-14 22:45　ルーターの電源を切られる。&lt;/li&gt;
&lt;li&gt;2015-03-14 22:16　59MB 残り７時間くらいと表示&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>StatusBarをSwiftで隠す</title>
      <link>http://goozenlab.com/blog/2015/03/statusbar-swift/</link>
      <pubDate>Sun, 15 Mar 2015 08:30:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>http://goozenlab.com/blog/2015/03/statusbar-swift/</guid>
      <description>&lt;p&gt;iOSやXCodeのバーションが上がったりすると必ず分からなくなる。statusbarの扱い。&lt;/p&gt;

&lt;p&gt;iOS8とswiftでは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;override func prefersStatusBarHidden() -&amp;gt; Bool {
    return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追加するだけで良い。んっ、こんだけ？だったけ？？問題無く動いているようなので、不問。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SwiftでConstantを扱う</title>
      <link>http://goozenlab.com/blog/2015/03/constants-swift/</link>
      <pubDate>Sat, 14 Mar 2015 09:30:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>http://goozenlab.com/blog/2015/03/constants-swift/</guid>
      <description>&lt;p&gt;Swiftへの移行はスタンフォードの講義を聞きつつ進めたいところなのですが、ここネパールだとちょっと無理。
ネットでの情報も増えつつはあるように思えるが、まだまだな感じ。。&lt;/p&gt;

&lt;p&gt;分からないことが多々あるが、進めていかないと、、&lt;/p&gt;

&lt;p&gt;さて、これが正しい方法なのかは分からないけれども（一抹の不安があるが。。）、コンスタンツの扱いをSwiftにて行うには以下のようにしてます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//
//  LocalConstants.swift
//

import Foundation

    let ONE_DAY = 86400

struct UDKey {
    static let DisplayColorMode = &amp;quot;color_mode&amp;quot;
}

struct Default {
    static let ColorMode = &amp;quot;kawaii&amp;quot;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、他からのアクセスは&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;defaults.setValue(Default.ColorMode, forKey: UDKey.DisplayColorMode)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにしています。&lt;/p&gt;

&lt;p&gt;※ Swiftでのenumが掴めない。意味が分からない。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>クラスが読み込めず</title>
      <link>http://goozenlab.com/blog/2015/03/unable-to-load-class/</link>
      <pubDate>Thu, 12 Mar 2015 16:30:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>http://goozenlab.com/blog/2015/03/unable-to-load-class/</guid>
      <description>&lt;p&gt;TapasをSwiftに移行中です。一番癖の無いアプリという事で白羽の矢があたりましたが、、、ブログに引っかかったところ等アップしていきたいと思ってます。&lt;/p&gt;

&lt;p&gt;さて、さて、まずは、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2015-03-11 16:23:14.627 tapas[9910:539155] CoreData: warning: 
Unable to load class named &#39;Item&#39; for entity &#39;Item&#39;.  
Class not found, using default NSManagedObject instead.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;というエラーがでる。ファイルはあるのだが、、&lt;/p&gt;

&lt;p&gt;これは、動く。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func configureCell(cell: UITableViewCell, atIndexPath indexPath: NSIndexPath) {
    let item = self.fetchedResultsController.objectAtIndexPath(indexPath) as NSManagedObject
    var cell = cell as ListViewCell
    cell.textLabel?.text = item.valueForKey(&amp;quot;name&amp;quot;)!.description
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、動かなーーーーい。。。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func configureCell(cell: UITableViewCell, atIndexPath indexPath: NSIndexPath) {
    let item = self.fetchedResultsController.objectAtIndexPath(indexPath) as Item
    var cell = cell as ListViewCell
    cell.textLabel?.text = item.name
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ネットで調べるにも、、、停電かつ、ネットが途切れ途切れ。。。二進も三進もいかん。。
解決したら加筆します。とりあえず保留。（素直にストーリーボードを使うかな。）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2015-03-12-pockhara.jpg&#34; alt=&#34;Pokhara street&#34; /&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>UserDefaultの初期値設定</title>
      <link>http://goozenlab.com/blog/2015/03/userdefault-register-defaults/</link>
      <pubDate>Sun, 08 Mar 2015 08:30:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>http://goozenlab.com/blog/2015/03/userdefault-register-defaults/</guid>
      <description>&lt;p&gt;AppDelegateで行なう処理の一つのUserDefaultの初期値設定をSwiftにて。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; // UserDefault Initial values
 var userDefaultsDefaults = NSMutableDictionary()
 userDefaultsDefaults.setValue(&amp;quot;String&amp;quot;, forKey: KEY_SETTING)
 userDefaultsDefaults.setValue(50, forKey: KEY_SETTING2)
 NSUserDefaults.standardUserDefaults().registerDefaults(userDefaultsDefaults)
 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数値も文字も気にせず書き込んでよいようです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2015-03-08-pokhara-damside.jpg&#34; alt=&#34;Pokhara&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;ポカラの水汲み場&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ライトウェイト マイグレーションでのアトリビュートの名称変更</title>
      <link>http://goozenlab.com/blog/2015/03/lightweight-migration-mapping/</link>
      <pubDate>Mon, 02 Mar 2015 08:30:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>http://goozenlab.com/blog/2015/03/lightweight-migration-mapping/</guid>
      <description>&lt;p&gt;タイトルが長げーーーーーーな。。&lt;/p&gt;

&lt;p&gt;さて、lightweight migration での移行で、アトリビュートの名前の変更がうまく行かないときは、マッピングがうまく機能していないのが原因です。（だとおもいます。）&lt;/p&gt;

&lt;p&gt;そんなときは、マッピングファイルを作成して、&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2015-03-02-db-migration2.png&#34; alt=&#34;Migration 1&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;ファイルを訂正、追加して（source, destinationに注意）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2015-03-02-db-migration1.png&#34; alt=&#34;Migration 2&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;あとは、optionsの設定を加え、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSDictionary *options = @{NSMigratePersistentStoresAutomaticallyOption: @(YES),
                              NSInferMappingModelAutomaticallyOption: @(YES)}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;if (![_persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:storeURL options:options error:&amp;amp;error]) {

# options:nil の箇所を options:options に変更
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常通り処理を行えば、うまく行きます。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;pre&gt;&lt;code&gt;- (NSPersistentStoreCoordinator *)persistentStoreCoordinator {
    // The persistent store coordinator for the application. This implementation creates and return a coordinator, having added the store for the application to it.
    if (_persistentStoreCoordinator != nil) {
        return _persistentStoreCoordinator;
    }
    
    // Create the coordinator and store
    _persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:[self managedObjectModel]];
    NSURL *storeURL = [[self applicationDocumentsDirectory] URLByAppendingPathComponent:@&amp;quot;Littlist.sqlite&amp;quot;];
   
    // Performing automatic lightweight migration by passing the following dictionary as the options parameter:
    NSDictionary *options = @{NSMigratePersistentStoresAutomaticallyOption: @(YES),
                              NSInferMappingModelAutomaticallyOption: @(YES)};

    NSError *error = nil;
    NSString *failureReason = @&amp;quot;There was an error creating or loading the application&#39;s saved data.&amp;quot;;
    if (![_persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:storeURL options:options error:&amp;amp;error]) {
        // Report any error we got.
        NSMutableDictionary *dict = [NSMutableDictionary dictionary];
        dict[NSLocalizedDescriptionKey] = @&amp;quot;Failed to initialize the application&#39;s saved data&amp;quot;;
        dict[NSLocalizedFailureReasonErrorKey] = failureReason;
        dict[NSUnderlyingErrorKey] = error;
        error = [NSError errorWithDomain:@&amp;quot;YOUR_ERROR_DOMAIN&amp;quot; code:9999 userInfo:dict];
        // Replace this with code to handle the error appropriately.
        // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
        NSLog(@&amp;quot;Unresolved error %@, %@&amp;quot;, error, [error userInfo]);
        abort();
    }
    return _persistentStoreCoordinator;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lightweight migrationでマッピングファイルが使えるとは知りませんでした。というかファイルの存在自体も知らなかった。。&lt;/p&gt;

&lt;p&gt;でも、これで変更の流れもつかめるしありがたや。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ニブレスプロジェクト</title>
      <link>http://goozenlab.com/blog/2015/02/xibless-project/</link>
      <pubDate>Thu, 26 Feb 2015 07:25:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>http://goozenlab.com/blog/2015/02/xibless-project/</guid>
      <description>&lt;p&gt;swiftに移行中です。折角なのでなるべく奇麗にやり直したい、ずる無しでシンプルに仕上げたい。&lt;/p&gt;

&lt;p&gt;ストーリーボードにはどうも馴染めず、結局中途半端にViewのコンポーネントをコードで書き込んだりする事になりそうなので、最初から何もなし状態から始めた方が良いと、、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;まずは storyboard/xib 無しテーブルビューベースのプロジェクト、MasterViewController (UITableViewController) がMainViewController です。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&amp;gt; Bool {
   // Override point for customization after application launch.

   self.window = UIWindow(frame: UIScreen.mainScreen().bounds)
   let masterViewController: MasterViewController = MasterViewController()
   masterViewController.managedObjectContext = self.managedObjectContext
   let navigationController = UINavigationController(rootViewController: masterViewController)
   self.window!.rootViewController = navigationController
   self.window!.makeKeyAndVisible()
   return true
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;お次ぎは、storyboard/xib 無しビューコントローラーベースのプロジェクト、MainViewController (UIViewController) が文字通り MainViewController です。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;、、が、、、、色々コンポーネントを追加していけば行くほど、アラートが上がってくる。。。（試行錯誤中）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&amp;gt; Bool {
    // Override point for customization after application launch.
    
    self.window = UIWindow(frame: UIScreen.mainScreen().bounds)

    let mainViewController = MainViewController()
    mainViewController.managedObjectContext = self.managedObjectContext

    self.window!.rootViewController = mainViewController
    self.window!.makeKeyAndVisible()
    
    return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;割と簡単に行きましたが、こんなものまで、調べつつやってます。。。let なのか var なのか、！なのか？なのか。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Reminder：日時の書き込み</title>
      <link>http://goozenlab.com/blog/2015/02/reminder-duedatecomponents/</link>
      <pubDate>Mon, 23 Feb 2015 06:50:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>http://goozenlab.com/blog/2015/02/reminder-duedatecomponents/</guid>
      <description>&lt;p&gt;リマインダーへの日時の書き込み&lt;/p&gt;

&lt;p&gt;読み込み時には&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;event.dueDate = eventToRead.dueDateComponents.date;
event.timeZone = eventToRead.dueDateComponents.timeZone;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と、あっさりと行くのですが、&lt;code&gt;.dueDateComponents.date&lt;/code&gt; は readonly で書き込み時には日時をバラバラにしてまとめて書き込みます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
  NSCalendar *gregorian = [[NSCalendar alloc]
                           initWithCalendarIdentifier:NSGregorianCalendar];
  unsigned unitFlags= NSYearCalendarUnit|NSMonthCalendarUnit | NSDayCalendarUnit |
   NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit |NSTimeZoneCalendarUnit;
  
  NSDateComponents *dailyComponents=[gregorian components:unitFlags fromDate:eventToExport.dueDate];
  
  eventToWrite.dueDateComponents = dailyComponents;
  eventToWrite.timeZone = eventToExport.timeZone;
  
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Reminderからの読込ではまる</title>
      <link>http://goozenlab.com/blog/2015/02/reminder-completion/</link>
      <pubDate>Sun, 22 Feb 2015 23:47:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>http://goozenlab.com/blog/2015/02/reminder-completion/</guid>
      <description>&lt;p&gt;ここ数日 littlist.2.6.5にReminderへの書込み・取込みの機能の追加作業をしていました。&lt;/p&gt;

&lt;p&gt;見事にハマったのが、取込みの&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (id)fetchRemindersMatchingPredicate:(NSPredicate *)predicate completion:(void (^)(NSArray *reminders))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;でのブロック処理。 完了時にリマインダーのリストが所得でき、そのリストをセーブすれば簡単なはず、、なのが、、なぜがしっかりと保存されていない。中途半端にブロックから出てきている模様。&lt;/p&gt;

&lt;p&gt;いろいろと試し、ネットで探したところ、見つかりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
    // 事前に calendar の設定等をして、
	
    __block NSArray *remindersToImport = nil;
    __block BOOL fetching = YES;
    
    NSPredicate *predicate = [eventStore predicateForRemindersInCalendars:@[calendar]];
    [eventStore fetchRemindersMatchingPredicate:predicate completion:^(NSArray *ekReminders) {
        LOG_METHOD;
        remindersToImport = ekReminders;
        fetching = NO;
    }];
    
    while (fetching) {
        [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.05]];
    }
    
    // 作業がつづく
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と、&lt;strong&gt;while&lt;/strong&gt; の所で、処理が終わるまで一服させ、作業を続ける形です。（何のためのブロック処理なのか意味が分かりませんし、こういうのはバグというのでは？？）&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>