<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Develop on goozenlab</title>
    <link>http://goozenlab.com/categories/develop/</link>
    <description>Recent content in Develop on goozenlab</description>
    <generator>Hugo -- gohugo.io</generator>
    <managingEditor>goozenlab@gmail.com (jin)</managingEditor>
    <webMaster>goozenlab@gmail.com (jin)</webMaster>
    <lastBuildDate>Fri, 26 Aug 2016 09:30:00 +0700</lastBuildDate>
    <atom:link href="http://goozenlab.com/categories/develop/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>StatusBarメモ</title>
      <link>http://goozenlab.com/blog/2016/08/statusbar-memo/</link>
      <pubDate>Fri, 26 Aug 2016 09:30:00 +0700</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>http://goozenlab.com/blog/2016/08/statusbar-memo/</guid>
      <description>&lt;p&gt;アプリにて、StatusBarを隠す事が多いのだけれど、いつもやり方を忘れるのでメモしておく。&lt;/p&gt;

&lt;p&gt;まずは全体的な設定を、info.plistにて &lt;code&gt;View Controller-based status bar appearance&lt;/code&gt; を追加。(ここのところがいつも「どれだったっけ？」とわからなくなる。）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2016-08-26-statusbar-info.png&#34; alt=&#34;StatusBar on Info.plist&#34; /&gt;&lt;/p&gt;

&lt;p&gt;info.plistに直接書き込むなら、以下を追加。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;key&amp;gt;UIViewControllerBasedStatusBarAppearance&amp;lt;/key&amp;gt;
	&amp;lt;false/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;そして、変更したいビューの適当なところ、&lt;code&gt;ViewDidLoad&lt;/code&gt; に追加コード。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UIApplication.sharedApplication().statusBarHidden = true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もしくは、オーバーライドしても動くはず。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;override func prefersStatusBarHidden() -&amp;gt; Bool {
    return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、ステータスバーの文字色、黒文字を白文字に変えるには、statusBarStyleStyleを &lt;code&gt;.LightContent&lt;/code&gt; に変更する。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UIApplication.sharedApplication().statusBarStyle = .LightContent
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Lite VersionとAdmob</title>
      <link>http://goozenlab.com/blog/2016/08/lite-admob/</link>
      <pubDate>Thu, 25 Aug 2016 09:30:00 +0700</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>http://goozenlab.com/blog/2016/08/lite-admob/</guid>
      <description>

&lt;p&gt;Swiftへの移行がちょっと落ち着いてきたので、お次はライトバージョンの制作に移る。同じプロジェクト内でライト版のターゲットをもつ方法で行います。ライト版では広告を表示するため、コード内のマクロで作業の分離を行います。(XCode7.3.1にて)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ターゲットのコピーと調整&lt;/li&gt;
&lt;li&gt;スキームの変更&lt;/li&gt;
&lt;li&gt;新しいInfo.plistのリネーム、変更と移動&lt;/li&gt;
&lt;li&gt;コンパイル時のマクロ設定&lt;/li&gt;
&lt;li&gt;アイコンの追加&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;が主な作業の流れになります。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;まずはプロジェクトのメインターゲットを Duplicate します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2016-08-22-lite-duplicate.png&#34; alt=&#34;Duplicate Target&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2016-08-22-lite-duplicate-dailog.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2016-08-22-lite-rename-target.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2016-08-22-lite-manage-scheme.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;スキーム名の変更はできないようなので、Editボタンの上の＋より、新しいスキームを追加します。ここの、cosper copyのものは＋の横のーボタンで消去します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2016-08-22-lite-add-scheme.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2016-08-22-lite-delete-scheme.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Info.plistのコピーの &lt;code&gt;cosper copy-Info.plist&lt;/code&gt; はなぜか諸々のファイルのフォルダーの外に作られます。ちょっと面倒ですが、リネームしリファレンスから除き、プロジェクトにコピーして移動、そしていらなくなったファイルを削除をしましょう。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2016-08-22-lite-rename.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2016-08-22-lite-taget-info-copy.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;そしてビルドセッティング内のInfo.plistパラメーターをディレクトリー名を含めたファイル名に変更します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2016-08-22-lite-target-info-rename.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;そして、ターゲットの設定をします。（バンドル名やその他必要なもの）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2016-08-22-lite-target-general.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;最後に、コンパイル時のマクロ設定をします。&lt;code&gt;#if LITE&lt;/code&gt; で処理を分岐できるようにします。LITE_VERSIONでもFREE_VERSIONでもご自分に適したものにしてください。&lt;/p&gt;

&lt;p&gt;マクロの設定は、ビルドセティングより、右のサーチボックスから検索していくと良いです。フル・ライト両方のターゲットで設定が必要です。ライトにて &lt;code&gt;LITE=1&lt;/code&gt; を、&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2016-08-22-lite-macro-lite.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;フルバージョンの方には &lt;code&gt;LITE=0&lt;/code&gt; を書き込みます。選択すると入力画面が出てきます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2016-08-22-lite-macro-full.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;そして、ライトバージョンでは、コンパイラーのカスタムフラグを設定します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2016-08-22-lite-macro-flag.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;アイコンもライトバージョン用に追加、変更します。アイコンは、Assets.xcassetsより作成し、ターゲットにて設定します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2016-08-22-lite-add-icon.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2016-08-22-lite-icon-resource.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;これで、ライトバージョンのターゲットが完成です。次に、ライトバージョンに広告を入れたいと思います。&lt;/p&gt;

&lt;h2 id=&#34;admobの追加:b595817e990569d4557e8d14af10d808&#34;&gt;AdMobの追加&lt;/h2&gt;

&lt;p&gt;iAdは終了してしまいましたので、定番Googleの AdMob をインストールします。CocoaPods を使って簡単にプロジェクトに追加することもできるのですが、私の開発機の不思議な不具合でココポッドを設定していません。。ファイルを落としてフレームワークを追加という手動インストールをします。（また、近くCocoaPodsを使った方法をアップデートするかもしれません。とりあえずココポッドでのインストール時には、Podfileに &lt;code&gt;target &#39;xx lite&#39; do ...&lt;/code&gt; で切り分ければいいのかな。）&lt;/p&gt;

&lt;h3 id=&#34;フレームワーク:b595817e990569d4557e8d14af10d808&#34;&gt;フレームワーク&lt;/h3&gt;

&lt;p&gt;必要なフレームワークは、以下。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GoogleMobileAds.framework: Googleサイトよりダウンロード、プロジェクトに&lt;strong&gt;コピー&lt;/strong&gt; (ターゲットをライトバージョンのみにするのを忘れずに）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2016-08-24-admob-copy-framework.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;プロジェクトからターゲットを選択して、一番下のLinked Frameworks and Librariesより追加、コマンド＋クリックで複数選択可能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2016-08-24-admob-add-frameworks.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AdSupport&lt;/li&gt;
&lt;li&gt;AudioToolbox&lt;/li&gt;
&lt;li&gt;AVFoundation&lt;/li&gt;
&lt;li&gt;CoreGraphics&lt;/li&gt;
&lt;li&gt;CoreTelephony&lt;/li&gt;
&lt;li&gt;EventKit&lt;/li&gt;
&lt;li&gt;EventKitUI&lt;/li&gt;
&lt;li&gt;MessageUI&lt;/li&gt;
&lt;li&gt;StoreKit&lt;/li&gt;
&lt;li&gt;SystemConfiguration&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上で準備完了。実装していきます。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;コーディング:b595817e990569d4557e8d14af10d808&#34;&gt;コーディング&lt;/h3&gt;

&lt;p&gt;マクロを使って、以下の形で処理を分けることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#if LITE
 	// ライトバージョンで行う処理
#else
 	// フルバージョンでの処理
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下記の例は、テーブルビューを使ったアプリでの表示例になっています。テーブルビューのヘッダー部分に広告が表示されます。（実際に使っているコードから引用。）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import UIKit
import CoreData
#if LITE
import GoogleMobileAds
#endif

class ListTableViewController: UITableViewController,NSFetchedResultsControllerDelegate {

    #if LITE
    /// The banner view.
    let GADApplicationID = &amp;quot;ca-app-pub-xxxxxxx/xxxxxxx&amp;quot;
    var bannerView: GADBannerView!
    #endif
    
    .......

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view, typically from a nib.
        setNavigationBarGestures()
        self.tableView.showsVerticalScrollIndicator = false
        self.tableView.rowHeight = Cell.Height

      .......

        #if LITE
            loadAdmob()
        #endif
     }

	.......
	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アドモブ用の処理ファイルを別にします。こちらもターゲットをライトバージョンのみにします。（ちょっとすっきりする。）デレゲートにて広告を受け取ったときにテーブルヘッダーに表示する形をとってます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2016-08-24-admob-extensrion.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//
//  Admob.swift
//

import UIKit
import GoogleMobileAds

extension ListTableViewController: GADBannerViewDelegate {
    
    func loadAdmob() {
        print(&amp;quot;Google Mobile Ads SDK version: \(GADRequest.sdkVersion())&amp;quot;)
        
        bannerView = GADBannerView(adSize: kGADAdSizeSmartBannerPortrait)
        bannerView.adUnitID = GADApplicationID
        bannerView.delegate = self
        bannerView.rootViewController = self
//	For Debug      
//        let request:GADRequest = GADRequest()
//        request.testDevices = [kGADSimulatorID]
//        bannerView.loadRequest(request)
        bannerView.loadRequest(GADRequest())
    }
        
    func adViewDidReceiveAd(bannerView: GADBannerView!) {
        print(&amp;quot;Admob:adViewDidReceiveAd&amp;quot;)
        let adMobView = bannerView
        
        UIView.beginAnimations(&amp;quot;AdBannerMoveOnScreen&amp;quot;, context: nil)
        self.bannerView.frame = CGRectMake(0.0, 0.0,
                                           adMobView.frame.size.width, adMobView.frame.size.height)
        self.tableView.tableHeaderView = self.bannerView
        UIView.commitAnimations()
    }
    
    func adView(bannerView: GADBannerView!, didFailToReceiveAdWithError error: GADRequestError!) {
        UIView.beginAnimations(&amp;quot;ClearBannerView&amp;quot;, context: nil)
        bannerView.frame = CGRectMake(0.0, 0.0, bannerView.frame.size.width, 0.0)
        tableView.tableHeaderView = bannerView        
        UIView.commitAnimations()
    }
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;割とあっさりと行きます。（こんな簡単だったけか？？なんか忘れてんのかと、ちと不安。。）&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>イフレット</title>
      <link>http://goozenlab.com/blog/2016/08/if-let/</link>
      <pubDate>Thu, 18 Aug 2016 09:30:00 +0700</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>http://goozenlab.com/blog/2016/08/if-let/</guid>
      <description>&lt;p&gt;&lt;code&gt;fatal error: unexpectedly found nil while unwrapping an Optional value&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;nil値が戻ってくる可能性のある時の処理方法。&lt;/p&gt;

&lt;p&gt;tableCellに値を渡す時を例に、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# if let xx  = yy { } else { }

if let lock  = event.isLocked as? Bool {
    cell.isLocked = lock
} else {
    cell.isLocked = false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で新しく、&lt;code&gt;guard let&lt;/code&gt; なんてのが出てきて、こんな風に書き換える事ができ、（&lt;code&gt;else&lt;/code&gt;以降の役割がよくわからない。）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# guard let xx = y else {]

guard let lock  = event.isLocked as? Bool else { return }
cell.isLocked = lock

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そしてしかも、簡略した（?：ニル、？：なの）&lt;code&gt;xx = yy ??&lt;/code&gt; もある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# xx = yy ??
cell.isLocked = event.isLocked as? Bool ?? false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基本的に同じものなのだろうか？一番下のものがなんとなく分かりやすい気も個人的にはするのだが、あまり推奨はされていないようにも思われる。。。場合によって使い分けるのが良いのか。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>filteredArrayUsingPredicate</title>
      <link>http://goozenlab.com/blog/2016/08/array_filter/</link>
      <pubDate>Thu, 04 Aug 2016 18:30:00 +0700</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>http://goozenlab.com/blog/2016/08/array_filter/</guid>
      <description>&lt;p&gt;拙作dandoriのswift移行中、中々進みません。&lt;/p&gt;

&lt;p&gt;Objective-Cで使っていた、filteredArrayUsingPredicate が Swiftでは簡略化。.filterメソッドを使い、ブロックで処理を書き込みます。。。&lt;/p&gt;

&lt;p&gt;ブロック表記が出てくると目が点になってしまう私。。。&lt;/p&gt;

&lt;p&gt;以下 Objective-C での表記&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSArray *myTasks = [[NSArray alloc] initWithArray:[event.tasks allObjects]];
NSPredicate *hotPredicate = [NSPredicate predicateWithFormat:@&amp;quot;isRedHot == YES&amp;quot;];
NSArray *filteredArray = [myTasks filteredArrayUsingPredicate:hotPredicate];
return [filteredArray count] &amp;gt; 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swiftで書き上げにはブロック内に&lt;code&gt;(user: UserDetails) -&amp;gt; Bool in&lt;/code&gt; で書き込む方法もあり試すもエラーがでる。。あーーー、ブロック、、意味わからん。。。しかし、救いの神のNSPredicateを使った場合は以下、随分スッキリします。（こっちの方が全然良いわ。。&lt;code&gt;
$0.isRedHot = &amp;quot;YES&amp;quot;&lt;/code&gt; 何じゃかんじゃより。。）書き上げるとこんな感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let myTasks = tasks?.allObjects
let predicate = NSPredicate(format: &amp;quot;isRedHot == YES&amp;quot;)
let filteredArray = myTasks?.filter( {
	predicate.evaluateWithObject($0)
	} )
return filteredArray!.count &amp;gt; 0
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>乱数を発生させる</title>
      <link>http://goozenlab.com/blog/2016/03/arc4random_uniform/</link>
      <pubDate>Fri, 18 Mar 2016 11:30:00 +0700</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>http://goozenlab.com/blog/2016/03/arc4random_uniform/</guid>
      <description>

&lt;h2 id=&#34;rand:dc776821942516eb940a9f207846a213&#34;&gt;rand()&lt;/h2&gt;

&lt;p&gt;今まではrand()使い、srand()にて乱数の初期化をし数値を得ていた。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; srand(time(nil));
 rand()%300;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;arc4random-uniform:dc776821942516eb940a9f207846a213&#34;&gt;arc4random_uniform()&lt;/h2&gt;

&lt;p&gt;上記の形だとSwift時にエラーが出る為、乱数の初期化が不要な物に変更し以下の形に落ち着く。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; Int(arc4random_uniform(300))
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>iOS 9.0.1</title>
      <link>http://goozenlab.com/blog/2015/09/ios901/</link>
      <pubDate>Fri, 25 Sep 2015 06:30:00 +0800</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>http://goozenlab.com/blog/2015/09/ios901/</guid>
      <description>&lt;p&gt;未だ実機にはiOS9を入れる事にためらいを感じているさなか、早くも9.0.1がリリースされる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2015-09-25-ios901.jpg&#34; alt=&#34;iOS9.0.1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;修正点の中でも気になるのは、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;アラームやタイマーが鳴らないことがある問題を修正&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これが、拙作のサティで問題になっている音が出ない問題の解決になっていることをちょっと期待。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>XCode7とElCapitan</title>
      <link>http://goozenlab.com/blog/2015/09/xcode7-elcapitan/</link>
      <pubDate>Thu, 24 Sep 2015 13:30:00 +0800</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>http://goozenlab.com/blog/2015/09/xcode7-elcapitan/</guid>
      <description>&lt;p&gt;アプリの不具合がレポートされ、今更ながら、iOS9向けの開発環境を整える事にする。&lt;/p&gt;

&lt;p&gt;まず、取り急ぎ実機での検証は先回しにして、シミュレータでの検証のため、SSDの領域を削りElCapitan/XCode7をインストールする。（色々あったが割愛する。）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2015-09-24-disk.jpg&#34; alt=&#34;Disk&#34; /&gt;&lt;/p&gt;

&lt;p&gt;メインのマシーンが昨年からスペックダウンしてMBA11.2014/4GB.128SSDとなり、かなりタイトな環境。XCode7をインストールしてちょっと使ってみるが、、、、もっさり感と引っかかりが出始める、、
うぅ～～～、レイアウトも崩れているし、、バグもそれなりにありそう。。（溜息）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2015-09-24-xcode7-elcapitan.jpg&#34; alt=&#34;XCode7+ElCapitan&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>iOS9での不具合：Satiの通知音</title>
      <link>http://goozenlab.com/blog/2015/09/ios9-bug-notifications/</link>
      <pubDate>Wed, 23 Sep 2015 15:30:00 +0800</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>http://goozenlab.com/blog/2015/09/ios9-bug-notifications/</guid>
      <description>&lt;p&gt;マインドフルな瞑想アプリのサティ、ユーザーの方からiOS9にアップデート以降、音が出なくなったとの報告を受けました。&lt;/p&gt;

&lt;p&gt;iOS8がリリースされた時にも、通知で音を出すには事前認証が必須になり、認証のプロセスを追加していなかったので、新規ユーザーの人たちには音が出ないという致命的なバグがありました。OSをアップデートしたインストール済のユーザーには不具合は無かったので、３ヶ月くらい放置していました。&lt;/p&gt;

&lt;p&gt;そして、今回もappleの新しい省電力モードや通知機能の拡張により（多分）、同様の不具合が発生。&lt;/p&gt;

&lt;p&gt;自分の検証端末がiPhone4S/iOS8.1のため、iOS9へのアップデートはちょっと悩んでいて、、
しかも、開発環境は未だマーベリックスを使っているため、iOS9向けの開発環境が未だ整っていない状態です。
iOS9自体はブラッシュアップ的なアプデートだと認識していたので、まぁ、大丈夫だろうとたかを括ってました。&lt;/p&gt;

&lt;p&gt;ネットでちょっと調べて見た所、似たような現象が起こっているのを幾つか発見しました。音の出ない瞑想タイマーではまるっきり体をなさないので、環境を整えて、なるべく速くアップデートしたいと思います。&lt;/p&gt;

&lt;p&gt;何か他にも不具合等が起こりましたら、連絡のほどよろしくお願いします。&lt;/p&gt;

&lt;p&gt;では、ロシアより愛を込めて、&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>iOS9にて気になる機能の3DTouch</title>
      <link>http://goozenlab.com/blog/2015/09/3dtouch/</link>
      <pubDate>Sun, 20 Sep 2015 09:30:00 +0800</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>http://goozenlab.com/blog/2015/09/3dtouch/</guid>
      <description>&lt;p&gt;iOS9にて操作動作が、強押し、さらに押込押しと深みが出る。
アップルの使い方のガイドラインではピーク＆ポップという形。
その対象に対しての関心の度合いを操作にしたいう感じ。&lt;/p&gt;

&lt;p&gt;自分のアプリで使っている長押しと被るような感じがあるのだが、どう追加して行くか考えている。&lt;/p&gt;

&lt;p&gt;例）リトリスト（todoアプリ）にて、&lt;br /&gt;
メニューバーの長押しでリストからホットリスト（重要項目のリスト）に移動するようになっている。
これは、強押しで重要項目の表示、さらに押して移動という形にできる。&lt;/p&gt;

&lt;p&gt;：おまけ：&lt;br /&gt;
自分の検証端末はいまだに iPhone4S （自分の中ではデザイン的に理想の携帯。母から契約終了端末を引き継ぐ）。iPhone6Sは機能的には惹かれるが、どうもハードのデザインに魅力を感じない。次のiphone7でフルモデルチェンジを期待。&lt;/p&gt;

&lt;p&gt;バイカル湖、オリフォン島
&lt;img src=&#34;http://goozenlab.com/images/2015-09-06-baikal.jpg&#34; alt=&#34;Olphon&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>NSUserDefaultsのキーの削除</title>
      <link>http://goozenlab.com/blog/2015/07/userdefaults-remove-keys/</link>
      <pubDate>Mon, 27 Jul 2015 18:30:00 +0500</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>http://goozenlab.com/blog/2015/07/userdefaults-remove-keys/</guid>
      <description>&lt;p&gt;アップデートをするたびに名前を変更したり、増えたり、減ったりしてグジャグジャになってしまう UserDefaults。私だけでは無いはず。。&lt;/p&gt;

&lt;p&gt;既に設定してしまったUserDefaultsのキーを削除する方法は以下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[NSUserDefaults standardUserDefaults] removeObjectForKey:@&amp;quot;kFontName&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アップデート時に実行させれば奇麗なままのUserDefaultを維持する事ができます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>midXで中心を求める</title>
      <link>http://goozenlab.com/blog/2015/07/midx-swift/</link>
      <pubDate>Sat, 11 Jul 2015 09:30:00 +0600</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>http://goozenlab.com/blog/2015/07/midx-swift/</guid>
      <description>&lt;p&gt;今までは中心を求めるのに素直に、&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let center: CGFloat = self.frame.width / 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と行ってきたけれども、.midX/midY&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let center: CGFloat = self.frame.midX
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とスマート、かつ格好良くできます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>テーブルビューセルの境界線を消す</title>
      <link>http://goozenlab.com/blog/2015/04/tableview-separator/</link>
      <pubDate>Mon, 06 Apr 2015 19:30:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>http://goozenlab.com/blog/2015/04/tableview-separator/</guid>
      <description>&lt;p&gt;テーブルビューセルの境界線を消すには下記のコードを追加。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;self.tableView.separatorStyle = UITableViewCellSeparatorStyle.None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;StoryBoardを使っている時は以下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2015-04-06-separator.png&#34; alt=&#34;Separator&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ShakeはUIEventで</title>
      <link>http://goozenlab.com/blog/2015/03/swift-shake/</link>
      <pubDate>Fri, 27 Mar 2015 11:30:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>http://goozenlab.com/blog/2015/03/swift-shake/</guid>
      <description>&lt;p&gt;色々と書き込んでいたシェイクの判別は&lt;code&gt;UIEvent&lt;/code&gt;を使うようになります。
えらく簡単になりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    override func viewDidAppear(animated: Bool) {
        super.viewDidAppear(animated)
        self.becomeFirstResponder()
    }
    
    override func canBecomeFirstResponder() -&amp;gt; Bool {
        return true
    }
    
    override func motionEnded(motion: UIEventSubtype, withEvent event: UIEvent!) {
        if(event.subtype == UIEventSubtype.MotionShake) {
            // 
            // 処理
            //
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://goozenlab.com/images/2015-03-26-shake-swift.png&#34; alt=&#34;swift shake&#34; /&gt;&lt;/p&gt;

&lt;p&gt;※まぁ、間違っちゃーいね〜な。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>performSelectorは無くなる</title>
      <link>http://goozenlab.com/blog/2015/03/performselector-timer/</link>
      <pubDate>Thu, 26 Mar 2015 10:30:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>http://goozenlab.com/blog/2015/03/performselector-timer/</guid>
      <description>&lt;p&gt;ほぼ全ての拙作のアプリでは、テーブルセルでのバーの色変更タップとアップデートは時間差を使って行っています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[NSObject cancelPreviousPerformRequestsWithTarget:self
                                         selector:@selector(notifiyUpdate)
                                           object:nil];
[self performSelector:@selector(notifiyUpdate)
           withObject:nil
           afterDelay:kUpdateCellShortInterval];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;object-cで上記に書かれた&lt;code&gt;performSelector&lt;/code&gt;はSwiftでは無くなってしまったようなので、以下のコードでは動かない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; NSObject.cancelPreviousPerformRequestsWithTarget(self, selector: notify, object: nil)
 NSObject.performSelector(notify, withObject: self, afterDelay: Interval.UpdateCell)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;幾つかの方法があるようですが、タイマーを使った方法が簡易でよいのですが、&lt;code&gt;cancelPreviousPerformRequestsWithTarget&lt;/code&gt;が無用になってしまう。処理の事前キャンセルも必要があるので、少し修正して最終的には以下のようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private var tapTimer: NSTimer?

// 処理
cancelTimer()
tapTimer = NSTimer.scheduledTimerWithTimeInterval(Interval.UpdateCell, target: self, selector:  notify, userInfo: nil, repeats: false)
//

func cancelTimer() {
    if tappingTimer != nil {
        tappingTimer!.invalidate()
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>printlnは気楽</title>
      <link>http://goozenlab.com/blog/2015/03/println-swift/</link>
      <pubDate>Wed, 25 Mar 2015 08:30:00 +0545</pubDate>
      <author>goozenlab@gmail.com (jin)</author>
      <guid>http://goozenlab.com/blog/2015/03/println-swift/</guid>
      <description>&lt;p&gt;NSLogはまだ使えるようですが、swiftではprintln をログの書出しに使います。NSLogだとよく使っていた、 &lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; は&lt;/p&gt;

&lt;p&gt;Swift では &lt;code&gt;__FILE__, __FUNCTION__, __LINE__ and __COLUMN__&lt;/code&gt; のようになります。
使えそうなのは&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__FILE__&lt;/code&gt;  ：ファイル名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__LINE__&lt;/code&gt; ：ライン番号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__FUNCTION__&lt;/code&gt; ：ファンクション名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;そして、値を表示したい時はそのままかそのままか&lt;code&gt;\(...)&lt;/code&gt;で囲み適当に放り込む。もはや%dや%@は必要ないらしい。
小賢しいウォーニングも出なくなる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;println(__FUNCTION__, self.frame)
println(__FUNCTION__,&amp;quot;screen is \(self.frame)&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;戻りは以下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function, (0.0,706.0,414.0,30.0))
(function, screen is (0.0,706.0,414.0,30.0))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift Programming Language に書いてあるらしいので読むべ。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>